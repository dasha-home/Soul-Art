<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="noindex, nofollow" />
  <title>Пульт управления — Soul-Art</title>
  <style>
    * { box-sizing: border-box; }
    body { font-family: system-ui, sans-serif; margin: 0; padding: 1.5rem; max-width: 900px; margin-left: auto; margin-right: auto; background: #0f0e14; color: #e0e0e0; }
    h1 { font-size: 1.5rem; margin-bottom: 1.5rem; }
    h2 { font-size: 1.15rem; margin: 1.5rem 0 0.75rem; color: #ff9ebb; }
    section { margin-bottom: 2rem; padding: 1rem; background: rgba(255,255,255,0.05); border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); }
    label { display: block; margin-top: 0.75rem; font-size: 0.9rem; }
    input[type="text"], input[type="file"], textarea { width: 100%; padding: 0.5rem 0.75rem; margin-top: 0.25rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.06); color: #fff; font: inherit; }
    textarea { min-height: 120px; resize: vertical; }
    button { margin-top: 0.75rem; padding: 0.5rem 1rem; border-radius: 8px; border: 1px solid rgba(255,107,156,0.4); background: rgba(255,107,156,0.2); color: #ff9ebb; cursor: pointer; font: inherit; }
    button:hover { background: rgba(255,107,156,0.35); }
    button.danger { border-color: rgba(255,100,100,0.5); background: rgba(255,100,100,0.15); color: #ff9999; }
    .msg { margin-top: 0.5rem; font-size: 0.85rem; min-height: 1.2em; }
    .msg.ok { color: #8dd; }
    .msg.err { color: #f88; }
    ul { list-style: none; padding: 0; margin: 0.5rem 0 0; }
    li { display: flex; align-items: center; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid rgba(255,255,255,0.08); gap: 0.5rem; }
    li span { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .hint { font-size: 0.8rem; color: #999; margin-top: 0.25rem; }
  </style>
</head>
<body>
  <h1>Пульт управления Soul-Art</h1>

  <p style="margin-bottom: 1.5rem; padding: 1rem; background: rgba(255,158,187,0.08); border-radius: 10px; border-left: 4px solid #ff9ebb; font-size: 0.95rem; line-height: 1.5;">
    <strong>Даша, всё хорошо.</strong> Ты просто выбираешь фото, при желании пишешь название и нажимаешь «Загрузить в галерею». Если появилась ошибка — не переживай: попробуй загрузить другой файл или изменить название (например, добавить цифру или буквы). Всё сохраняется само.
  </p>

  <section>
    <h2>Галерея</h2>
    <p class="hint">Только изображения: JPG, JPEG, PNG, WebP. Файл автоматически сжимается и конвертируется в WebP.</p>
    <label>Фото <input type="file" id="gallery-file" accept=".jpg,.jpeg,.png,.webp" /></label>
    <label>Название <input type="text" id="gallery-title" placeholder="Название работы" /></label>
    <button type="button" id="gallery-upload">Загрузить в галерею</button>
    <p id="gallery-msg" class="msg" aria-live="polite"></p>
    <h3>Элементы галереи</h3>
    <ul id="gallery-list"></ul>
  </section>

  <section>
    <h2>Рассказ</h2>
    <label>Заголовок <input type="text" id="story-title" placeholder="Заголовок рассказа" /></label>
    <label>Обложка <input type="file" id="story-cover" accept=".jpg,.jpeg,.png,.webp" /></label>
    <label>Текст <textarea id="story-content" placeholder="Текст рассказа..."></textarea></label>
    <button type="button" id="story-save">Сохранить рассказ</button>
    <p id="story-msg" class="msg" aria-live="polite"></p>
    <h3>Рассказы</h3>
    <ul id="stories-list"></ul>
  </section>

  <script>

  const GITHUB_TOKEN = "ВАШ КЛЮЧ СЮДА";
  const OWNER = "dasha-home";
  const REPO = "Soul-Art";
  const BRANCH = "main";
  const ALLOWED_IMAGE_EXT = /\.(jpe?g|png|webp)$/i;

  const API = "https://api.github.com/repos/" + OWNER + "/" + REPO + "/contents/";

  function setMsg(id, text, ok) {
    const el = document.getElementById(id);
    el.textContent = text;
    el.className = "msg " + (ok ? "ok" : "err");
  }

  function isAllowedImageFile(file) {
    if (!file || !file.name) return false;
    return ALLOWED_IMAGE_EXT.test(file.name);
  }

  function compressImageToWebP(file, targetMinKB, targetMaxKB) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      const url = URL.createObjectURL(file);
      img.onload = function () {
        URL.revokeObjectURL(url);
        const maxDim = 2400;
        let w = img.naturalWidth;
        let h = img.naturalHeight;
        if (w > maxDim || h > maxDim) {
          if (w > h) {
            h = Math.round((h * maxDim) / w);
            w = maxDim;
          } else {
            w = Math.round((w * maxDim) / h);
            h = maxDim;
          }
        }
        const canvas = document.createElement("canvas");
        canvas.width = w;
        canvas.height = h;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, w, h);

        function toBlobAsync(q) {
          return new Promise((res) => {
            canvas.toBlob(function (blob) {
              res(blob ? { blob, sizeKb: blob.size / 1024 } : null);
            }, "image/webp", q);
          });
        }

        function tryScale(scale) {
          const w2 = Math.max(1, Math.round(w * scale));
          const h2 = Math.max(1, Math.round(h * scale));
          const c2 = document.createElement("canvas");
          c2.width = w2;
          c2.height = h2;
          c2.getContext("2d").drawImage(img, 0, 0, w2, h2);
          return new Promise((res) => {
            c2.toBlob(function (blob) {
              res(blob ? { blob, sizeKb: blob.size / 1024 } : null);
            }, "image/webp", 0.82);
          });
        }

        (function attempt(quality) {
          toBlobAsync(quality).then(function (r) {
            if (!r) {
              reject(new Error("Браузер не поддерживает WebP"));
              return;
            }
            if (r.sizeKb >= targetMinKB && r.sizeKb <= targetMaxKB) {
              resolve(r.blob);
              return;
            }
            if (r.sizeKb > targetMaxKB && quality > 0.45) {
              attempt(Math.max(0.45, quality - 0.15));
              return;
            }
            if (r.sizeKb > targetMaxKB && quality <= 0.5) {
              tryScale(0.8).then(function (r2) {
                if (r2 && r2.sizeKb <= targetMaxKB) resolve(r2.blob);
                else resolve(r.blob);
              });
              return;
            }
            resolve(r.blob);
          });
        })(0.88);
      };
      img.onerror = function () {
        URL.revokeObjectURL(url);
        reject(new Error("Не удалось загрузить изображение"));
      };
      img.src = url;
    });
  }

  function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const r = new FileReader();
      r.onload = () => resolve(r.result.replace(/^data:[^;]+;base64,/, ""));
      r.onerror = reject;
      r.readAsDataURL(blob);
    });
  }

  async function api(path, method, body) {
    const res = await fetch(API + path, {
      method: method || "GET",
      headers: {
        "Accept": "application/vnd.github.v3+json",
        "Authorization": "token " + GITHUB_TOKEN,
        "Content-Type": "application/json"
      },
      body: body ? JSON.stringify(body) : undefined
    });
    if (!res.ok) {
      const j = await res.json().catch(() => ({}));
      throw new Error(j.message || res.statusText || "Ошибка API");
    }
    return res.status === 204 ? null : res.json();
  }

  function fileToBase64(file) {
    return new Promise((resolve, reject) => {
      const r = new FileReader();
      r.onload = () => resolve(r.result.replace(/^data:[^;]+;base64,/, ""));
      r.onerror = reject;
      r.readAsDataURL(file);
    });
  }

  function safeName(name) {
    return name.replace(/\.[^.]+$/, "").replace(/[^a-zA-Z0-9_-]/g, "_").slice(0, 40) || "img";
  }

  var RU_TO_LAT = { "а":"a","б":"b","в":"v","г":"g","д":"d","е":"e","ё":"e","ж":"zh","з":"z","и":"i","й":"j","к":"k","л":"l","м":"m","н":"n","о":"o","п":"p","р":"r","с":"s","т":"t","у":"u","ф":"f","х":"h","ц":"ts","ч":"ch","ш":"sh","щ":"sch","ъ":"","ы":"y","ь":"","э":"e","ю":"yu","я":"ya",
    "А":"a","Б":"b","В":"v","Г":"g","Д":"d","Е":"e","Ё":"e","Ж":"zh","З":"z","И":"i","Й":"j","К":"k","Л":"l","М":"m","Н":"n","О":"o","П":"p","Р":"r","С":"s","Т":"t","У":"u","Ф":"f","Х":"h","Ц":"ts","Ч":"ch","Ш":"sh","Щ":"sch","Ъ":"","Ы":"y","Ь":"","Э":"e","Ю":"yu","Я":"ya" };
  function transliterate(str) {
    var s = (str || "").normalize("NFC");
    return s.toLowerCase().split("").map(function(c) { return RU_TO_LAT[c] !== undefined ? RU_TO_LAT[c] : c; }).join("");
  }

  /** Уникальное имя файла (добавляем время), чтобы не перезаписывать и не нужен sha при загрузке. */
  function toWebpFilename(fileName) {
    var nameOnly = (fileName || "").replace(/\.[^.]+$/, "");
    var transliterated = transliterate(nameOnly);
    var base = transliterated.replace(/[^a-zA-Z0-9_-]/g, "_").replace(/_+/g, "_").replace(/^_|_$/g, "").slice(0, 30);
    if (!base || /^_+$/.test(base)) base = "img";
    return base + "_" + Date.now() + ".webp";
  }

  async function getFileSha(path) {
    var data = await api(path, "GET");
    return data.sha || null;
  }

  async function getJson(path) {
    const data = await api(path, "GET");
    const raw = atob(data.content.replace(/\n/g, ""));
    return JSON.parse(decodeURIComponent(escape(raw)));
  }

  async function putJson(path, obj, message, sha) {
    const str = JSON.stringify(obj, null, 2);
    const content = btoa(unescape(encodeURIComponent(str)));
    return api(path, "PUT", { message, content, sha: sha || undefined, branch: BRANCH });
  }

  async function deleteFile(path, message) {
    const data = await api(path, "GET");
    return api(path, "DELETE", { message, sha: data.sha, branch: BRANCH });
  }

  async function loadGallery() {
    try {
      const data = await getJson("data/gallery.json");
      return Array.isArray(data.artworks) ? data.artworks : [];
    } catch (_) {
      try {
        const r = await fetch("./data/gallery.json", { cache: "no-store" });
        if (r.ok) {
          const data = await r.json();
          return Array.isArray(data.artworks) ? data.artworks : [];
        }
      } catch (_) {}
      return [];
    }
  }

  document.getElementById("gallery-upload").addEventListener("click", async () => {
    const fileInput = document.getElementById("gallery-file");
    const titleInput = document.getElementById("gallery-title");
    const file = fileInput.files[0];
    if (!file) {
      setMsg("gallery-msg", "Выберите файл", false);
      return;
    }
    if (!isAllowedImageFile(file)) {
      setMsg("gallery-msg", "Разрешены только JPG, JPEG, PNG, WebP. Выберите изображение.", false);
      return;
    }
    if (GITHUB_TOKEN === "ВАШ КЛЮЧ СЮДА" || !GITHUB_TOKEN.trim()) {
      setMsg("gallery-msg", "Ошибка: вставьте токен в константу GITHUB_TOKEN в начале файла.", false);
      return;
    }
    const title = (titleInput.value || "").trim() || file.name;
    setMsg("gallery-msg", "Подключение к GitHub…", true);
    try {
      var galleryData = await api("data/gallery.json", "GET");
    } catch (e) {
      setMsg("gallery-msg", "Ошибка: не удалось прочитать галерею с GitHub. Проверьте токен и сеть.", false);
      return;
    }
    var items = [];
    if (galleryData && galleryData.content) {
      try {
        var raw = atob(galleryData.content.replace(/\n/g, ""));
        items = (JSON.parse(decodeURIComponent(escape(raw))).artworks || []).slice();
      } catch (_) {}
    }
    setMsg("gallery-msg", "Сжатие и конвертация в WebP…", true);
    try {
      const webpBlob = await compressImageToWebP(file, 500, 700);
      const base64 = await blobToBase64(webpBlob);
      const filename = toWebpFilename(file.name);
      const imgPath = "img/" + filename;
      setMsg("gallery-msg", "Загрузка изображения…", true);
      await api(imgPath, "PUT", {
        message: "Добавить фото в галерею (WebP): " + filename,
        content: base64,
        branch: BRANCH
      });
      const id = "g" + Date.now();
      items.push({ id, title, subtitle: "", imageUrl: "./" + imgPath });
      setMsg("gallery-msg", "Обновление списка галереи…", true);
      await putJson("data/gallery.json", { artworks: items }, "Добавить в галерею: " + title, galleryData.sha);
      setMsg("gallery-msg", "Готово. Файл загружен в галерею.", true);
      fileInput.value = "";
      titleInput.value = "";
      renderGalleryList();
    } catch (e) {
      setMsg("gallery-msg", "Ошибка: " + (e.message || ""), false);
    }
  });

  async function renderGalleryList() {
    const list = document.getElementById("gallery-list");
    const items = await loadGallery();
    list.innerHTML = items.map(item => {
      const path = (item.imageUrl || "").replace("./", "");
      return "<li><span>" + escapeHtml(item.title) + "</span><button type=\"button\" class=\"danger\" data-path=\"" + escapeHtml(path) + "\" data-id=\"" + escapeHtml(item.id) + "\">Удалить</button></li>";
    }).join("");
    list.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("click", async () => {
        if (!confirm("Удалить этот элемент и файл изображения?")) return;
        const path = btn.getAttribute("data-path");
        const id = btn.getAttribute("data-id");
        try {
          if (GITHUB_TOKEN === "ВАШ КЛЮЧ СЮДА" || !GITHUB_TOKEN.trim()) throw new Error("Вставьте токен");
          if (path) {
            try { await deleteFile(path, "Удалить из галереи"); } catch (_) { /* файл мог отсутствовать (404) */ }
          }
          const items = (await loadGallery()).filter(x => x.id !== id);
          const data = await api("data/gallery.json", "GET");
          await putJson("data/gallery.json", { artworks: items }, "Удалить из галереи", data.sha);
          renderGalleryList();
          setMsg("gallery-msg", "Удалено.", true);
        } catch (e) {
          setMsg("gallery-msg", "Ошибка: " + (e.message || ""), false);
        }
      });
    });
  }

  async function loadStories() {
    try {
      const data = await getJson("data/stories.json");
      return Array.isArray(data.stories) ? data.stories : [];
    } catch (_) {
      return [];
    }
  }

  document.getElementById("story-save").addEventListener("click", async () => {
    const titleInput = document.getElementById("story-title");
    const contentInput = document.getElementById("story-content");
    const coverInput = document.getElementById("story-cover");
    const title = (titleInput.value || "").trim();
    const content = (contentInput.value || "").trim();
    if (!title) {
      setMsg("story-msg", "Введите заголовок", false);
      return;
    }
    const coverFile = coverInput.files[0];
    if (coverFile && !isAllowedImageFile(coverFile)) {
      setMsg("story-msg", "Обложка: только JPG, JPEG, PNG, WebP", false);
      return;
    }
    setMsg("story-msg", "Сохранение…", true);
    try {
      if (GITHUB_TOKEN === "ВАШ КЛЮЧ СЮДА" || !GITHUB_TOKEN.trim()) throw new Error("Вставьте токен в GITHUB_TOKEN");
      let coverUrl = "";
      if (coverFile) {
        const webpBlob = await compressImageToWebP(coverFile, 400, 600);
        const base64 = await blobToBase64(webpBlob);
        const baseCover = (coverFile.name || "").replace(/\.[^.]+$/, "").replace(/[^a-zA-Z0-9_-]/g, "_").slice(0, 32) || "cover";
        const filenameWebp = "story-" + baseCover + ".webp";
        const path = "img/" + filenameWebp;
        var existingSha = null;
        try { existingSha = await getFileSha(path); } catch (_) {}
        var putBody = { message: "Обложка рассказа (WebP)", content: base64, branch: BRANCH };
        if (existingSha) putBody.sha = existingSha;
        await api(path, "PUT", putBody);
        coverUrl = "./" + path;
      }
      const stories = await loadStories();
      const id = "s" + Date.now();
      stories.push({ id, title, coverUrl, content });
      const data = await api("data/stories.json", "GET").catch(() => null);
      await putJson("data/stories.json", { stories }, "Добавить рассказ: " + title, data ? data.sha : undefined);
      setMsg("story-msg", "Готово.", true);
      titleInput.value = "";
      contentInput.value = "";
      coverInput.value = "";
      renderStoriesList();
    } catch (e) {
      setMsg("story-msg", "Ошибка: " + (e.message || ""), false);
    }
  });

  async function renderStoriesList() {
    const list = document.getElementById("stories-list");
    const items = await loadStories();
    list.innerHTML = items.map(s => "<li><span>" + escapeHtml(s.title) + "</span><button type=\"button\" class=\"danger\" data-id=\"" + escapeHtml(s.id) + "\">Удалить</button></li>").join("");
    list.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("click", async () => {
        if (!confirm("Удалить этот рассказ?")) return;
        const id = btn.getAttribute("data-id");
        try {
          if (GITHUB_TOKEN === "ВАШ КЛЮЧ СЮДА" || !GITHUB_TOKEN.trim()) throw new Error("Вставьте токен");
          const stories = await loadStories();
          const one = stories.find(x => x.id === id);
          if (one && one.coverUrl) {
            const path = one.coverUrl.replace("./", "");
            try { await deleteFile(path, "Удалить обложку"); } catch (_) {}
          }
          const next = stories.filter(x => x.id !== id);
          const data = await api("data/stories.json", "GET");
          await putJson("data/stories.json", { stories: next }, "Удалить рассказ", data.sha);
          renderStoriesList();
          setMsg("story-msg", "Удалено.", true);
        } catch (e) {
          setMsg("story-msg", "Ошибка: " + (e.message || ""), false);
        }
      });
    });
  }

  function escapeHtml(s) {
    const d = document.createElement("div");
    d.textContent = s;
    return d.innerHTML;
  }

  renderGalleryList();
  renderStoriesList();
  </script>
</body>
</html>
